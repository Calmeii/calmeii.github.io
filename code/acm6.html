<!DOCTYPE html><html><head><title>并查集（Union Find）</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'></head><body><div id='preview-contents' class='note-content'>
                        <div id="wmd-preview" class="preview-content"></div>
                    <div id="wmd-preview-section-1" class="wmd-preview-section preview-content">

</div><div id="wmd-preview-section-2" class="wmd-preview-section preview-content">

<h1 id="并查集union-find">并查集（Union Find）</h1>

</div><div id="wmd-preview-section-3" class="wmd-preview-section preview-content">

<h2 id="定义">定义</h2>

<p><strong>并查集</strong>是一种树型的数据结构，用于处理一些<strong>不相交集合</strong>（Disjoint Sets）的<strong>合并</strong>及<strong>查询</strong>问题。常常在使用中以森林来表示。 <br>
<strong>集</strong>就是让每个元素构成一个单元素的<strong>集合</strong>，也就是按一定顺序将属于同一组的元素所在的集合合并。 <br>
<strong>并查集</strong>可以理解为<strong>查找</strong>和<strong>合并</strong>的并组成<strong>集合</strong>。即在<strong>合并</strong>前<strong>查找</strong>两个元素是否属于同一个集合。如果不是就将其合并为一个集合。</p>

</div><div id="wmd-preview-section-4" class="wmd-preview-section preview-content">

<h2 id="基本操作">基本操作</h2>

</div><div id="wmd-preview-section-5" class="wmd-preview-section preview-content">

<h4 id="初始化">初始化</h4>

<p>　　<strong>把每个点所在集合初始化为其自身(即将自己赋为自己的根节点)</strong></p>

</div><div id="wmd-preview-section-6" class="wmd-preview-section preview-content">

<h3 id="查找">查找</h3>

<p>　　<strong>查找元素所在的集合即根节点</strong></p>

</div><div id="wmd-preview-section-7" class="wmd-preview-section preview-content">

<h3 id="合并">合并</h3>

<p>　　<strong>将两个元素所在的集合合并为一个集合</strong> <br>
　　<strong>合并两个不相交集合判断两个元素是否属于同一集合</strong></p>

</div><div id="wmd-preview-section-8" class="wmd-preview-section preview-content">

<h2 id="基本思想">基本思想</h2>

<p>初始时n个元素分属不同的n个集合，通过不断的给出元素间的联系，要求实时的统计元素间的关系（直接或间接的联系），可用并查集加以判断。 <br>
   1)元素间是否有联系：判断两个元素是否属于同一个集合；（查) <br>
   (2)建立元素间的联系：只需合并两个元素各自所属的集合。(并） <br>
    并查集本身不具有结构，必须借助一定的数据结构以得到支持和实现。一般用的比较多的是数组、链表和树来实现。</p>

</div><div id="wmd-preview-section-9" class="wmd-preview-section preview-content">

<h2 id="数组实现">数组实现</h2>

<p><strong>查找根节点</strong></p>

<pre class="prettyprint hljs-dark"><code class="hljs cpp"><div><div><div><div><div><div><div><div><div><div><div><div><div><div><div><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>           <span class="hljs-comment">//查找根节点</span></span></div><div> {</div><div>    <span class="hljs-keyword">int</span> r=x;              <span class="hljs-comment">//用r去保存x，查找根节点，不然x值会改变</span></div><div>    <span class="hljs-keyword">while</span>(father[r]!=r)   <span class="hljs-comment">//父节点不是自己是查找</span></div><div>    {</div><div>        r=father[r];      <span class="hljs-comment">//将他的父节点赋给自己，继续查找父节点的父节点</span></div><div>    }</div><div>    <span class="hljs-keyword">return</span> r;</div><div>  }</div><br></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></code></pre>

<p><strong>将两个元素合并为一个集合</strong></p>

<pre class="prettyprint hljs-dark"><code class="hljs gradle"><div><div><div><div><div><div><div><div><div><div><div><div><div><div><div><div> <span class="hljs-keyword">void</span> <span class="hljs-keyword">join</span>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)            <span class="hljs-comment">//判断x y是否为一个集合，如果不是就会把两个节点连通，不是就没有操作</span></div><div> {</div><div>    <span class="hljs-keyword">int</span> fax=<span class="hljs-keyword">Find</span>(x), fay=<span class="hljs-keyword">Find</span>(y); <span class="hljs-comment">//先查找到两个元素的根节点</span></div><div>    <span class="hljs-keyword">if</span>(fax!=fay)                  <span class="hljs-comment">//比对两个根节点是否为一个节点</span></div><div>    father[fay]=fax;              <span class="hljs-comment">//如果不是将y的父节点设为x的根节点，即y加入x的集合</span></div><div> }</div><br></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></code></pre>

</div><div id="wmd-preview-section-238" class="wmd-preview-section preview-content">

<h2 id="优化">优化</h2>

</div><div id="wmd-preview-section-239" class="wmd-preview-section preview-content">

<h3 id="路径压缩">路径压缩</h3>

<p><strong>每一次查找根节点都会依次往上查找，我们可以把已经查找到根节点的父节点改为它的根节点，这样会使后面的查找更容易</strong></p>

<blockquote>
  <p>非递归实现</p>
</blockquote>

<pre class="prettyprint hljs-dark"><code class="hljs gcode"><div><div>      <span class="hljs-keyword">while</span><span class="hljs-comment">(father[i]!=r)</span>   <span class="hljs-comment">//当父节点不是根节点时压缩</span></div><div>    {</div><div>        j=father[i];       <span class="hljs-comment">//用j保存当前父节点</span></div><div>        father[i]=r;       <span class="hljs-comment">//将父节点改为根节点</span></div><div>        i=j;               <span class="hljs-comment">//继续父节点的根节点</span></div><div>    }</div><br></div></code></pre>

<blockquote>
  <p>递归实现</p>
</blockquote>

<pre class="prettyprint hljs-dark"><code class="hljs gradle"><div><div> <span class="hljs-keyword">int</span> <span class="hljs-keyword">Find</span>(<span class="hljs-keyword">int</span> x)</div><div> {</div><div>    <span class="hljs-keyword">if</span> (x != father[x])</div><div>    {</div><div>       <span class="hljs-keyword">return</span> father[x] = <span class="hljs-keyword">Find</span>(father[x]);</div><div>     }</div><div>    <span class="hljs-keyword">return</span> x;</div><div>}</div><br></div></code></pre></div><div id="wmd-preview-section-11" class="wmd-preview-section preview-content">

<h2 id="举一个例子">举一个例子</h2>

<p>杭电1232畅通工程 <br>
 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1232</a> <br>
某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ </p>

<blockquote>
  <p>Input</p>
  
  <p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。  <br>
  注意:两个城市之间可以有多条道路相通,也就是说 <br>
  3 3 <br>
  1 2 <br>
  1 2 <br>
  2 1 <br>
  这种输入也是合法的 <br>
  当N为0时，输入结束，该用例不被处理。  <br>
  Output <br>
  对每个测试用例，在1行里输出最少还需要建设的道路数目。  <br>
  Sample Input <br>
  4 2 <br>
  1 3 <br>
  4 3 <br>
  3 3 <br>
  1 2 <br>
  1 3 <br>
  2 3 <br>
  5 2 <br>
  1 2 <br>
  3 5 <br>
  999 0 <br>
  0 <br>
  Sample Output <br>
  1 <br>
  0 <br>
  2 <br>
  998</p>
</blockquote>

</div><div id="wmd-preview-section-12" class="wmd-preview-section preview-content">

<h2 id="下面是代码">下面是代码：</h2>

<pre class="prettyprint hljs-dark"><code class="hljs cpp"><div><div><div><div><div><div><div><div><div><div><div><div><div><div><div><div>    <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;cstdio&gt;</span></div><div>    <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;iostream&gt;</span></div><div>    <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;cstring&gt;</span></div><div>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</div><br><div>    <span class="hljs-keyword">int</span> father[<span class="hljs-number">1000</span>+<span class="hljs-number">7</span>];</div><div>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>           <span class="hljs-comment">//查找根节点</span></span></div><div>    {</div><div>    <span class="hljs-keyword">int</span> r=x;              <span class="hljs-comment">//用r去保存x，查找根节点，不然x值会改变</span></div><div>    <span class="hljs-keyword">while</span>(father[r]!=r)   <span class="hljs-comment">//父节点不是自己是查找</span></div><div>    {</div><div>        r=father[r];      <span class="hljs-comment">//将他的父节点赋给自己，继续查找父节点的父节点</span></div><div>    }</div><div>    <span class="hljs-keyword">int</span> i=x,j;            <span class="hljs-comment">//下面是路径压缩</span></div><div>    <span class="hljs-keyword">while</span>(father[i]!=r)   <span class="hljs-comment">//当父节点不是根节点时压缩</span></div><div>    {</div><div>        j=father[i];       <span class="hljs-comment">//用j保存当前父节点</span></div><div>        father[i]=r;       <span class="hljs-comment">//将父节点改为根节点</span></div><div>        i=j;               <span class="hljs-comment">//继续父节点的根节点</span></div><div>    }</div><div>    <span class="hljs-keyword">return</span> r;</div><div>    }</div><div>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span>            <span class="hljs-comment">//判断x y是否为一个集合，如果不是就会把两个节点连通，不是就没有操作</span></span></div><div>    {</div><div>    <span class="hljs-keyword">int</span> fax=Find(x), fay=Find(y); <span class="hljs-comment">//先查找到两个元素的根节点</span></div><div>    <span class="hljs-keyword">if</span>(fax!=fay)                  <span class="hljs-comment">//比对两个根节点是否为一个节点</span></div><div>    father[fay]=fax;              <span class="hljs-comment">//如果不是将y的父节点设为x的根节点，即y加入x的集合</span></div><div>    }</div><div>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></div><div>    {</div><div>    <span class="hljs-keyword">int</span> N, M;</div><div>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;N, &amp;M))</div><div>    {</div><div>        <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>)</div><div>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</div><div>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)</div><div>        {</div><div>            father[i]=i;</div><div>        }</div><div>        <span class="hljs-keyword">int</span> a, b;</div><div>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=M;i++)</div><div>        {</div><div>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;a, &amp;b);</div><div>            join(a, b);</div><div>        }</div><div>        <span class="hljs-keyword">int</span> ans[<span class="hljs-number">1000</span>+<span class="hljs-number">7</span>];</div><div>        <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ans));</div><div>        <span class="hljs-comment">/*for(int i=1;i&lt;=N;i++)</span></div><div>        {</div><div>            printf("%d  ",father[i]);</div><div>        }*/</div><div>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)       <span class="hljs-comment">//标记有几个集合</span></div><div>        {</div><div>            ans[Find(i)]=<span class="hljs-number">1</span>;</div><div>        }</div><div>        <span class="hljs-keyword">int</span> ansr=<span class="hljs-number">0</span>; </div><div>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)       <span class="hljs-comment">//查找到一个集合，道路就要+1</span></div><div>        {</div><div>            <span class="hljs-keyword">if</span>(ans[i])</div><div>            ansr++;</div><div>        }</div><div>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ansr-<span class="hljs-number">1</span>);      <span class="hljs-comment">// 最后的道路要-1，因为n个集合只需n-1条线就可以连接起来</span></div><div>    }</div><div>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</div><div>    }</div><br></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></code></pre></div><div id="wmd-preview-section-footnotes" class="preview-content"></div></div></body></html>